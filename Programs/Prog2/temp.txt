#include <iostream>
#include <fstream> 
#include <algorithm>
#include "board.h"
using namespace std;


Board::Board()
{
}

void Board::CreateBoard(string fileName)
{     
    ifstream file;
    file.open(fileName);
    string curLine = "";
    int rowCount = 0;
    int colCount = 0;
    while(file >> curLine)
    {
        vector<Cell> row;
        for(char i : curLine)
        {
            Cell cell = Cell();
            if(i == '1')
            {
                cell.SetSolid();
                cell.SetVisitNum(1);
            }
            else if(toupper(i) == 'E')
            {
                cell.SetEntrance();
                cell.SetVisitNum(2);
                cell.SetRow(rowCount);
                cell.SetCol(colCount);
                cell.SetCord();
                queue.push(cell);
            }
            else
            {
                cell.SetVoid();
                cell.SetVisitNum(0);
            }
            cell.SetRow(rowCount);
            cell.SetCol(colCount);
            cell.SetCord();
            row.push_back(cell);
            ++colCount;
        }
        maze.push_back(row);
        colCount = 0;
        ++rowCount;
    }
    width = maze[0].size();
    height = maze.size();
    file.close();
}

void Board::WriteBoard(vector<vector<Cell> > board, string output, bool pathExist)
{
    ofstream file;
    file.open(output);
    for (int i = 0; i < board.size(); i++)
    {
        for (int j = 0; j < board[0].size(); j++)
        {
            if(board[i][j].isPath && pathExist)
            {
                if(board[i][j].GetCell() != 'E')
                {
                    file << ' ';
                }
                else
                {
                    file << 'E';
                }
            }
            else
            {
                file << board[i][j].GetCell();
            }
        }
        file << endl;
    }
    if(pathExist)
    {
        file << endl << "COORDS EXIT TO ENTRANCE:" << endl;
        while(!path.empty())
        {
            Cell i = path.front();
            file << '(' << i.GetCord() << ')' << endl;
            path.pop();
        }
        file << "TOTAL MOVES: " << to_string(pathLen);
    }
    else
    {
        file << "NO PATH EXISTS!";
    }
}

bool Board::SearchBoard()
{
    vector<int> colD = {0, width - 1};
    vector<int> rowD = {0, height - 1};
    vector<int> checks = {-1,0,0,1,1,0,0,-1};
    int visitNum = 3;
    int i, j;
    bool found = false;
    while(queue.size() != 0)
    {
        Cell cellToCheck = queue.front();
        stack.push(cellToCheck);
        queue.pop();
        if((cellToCheck.GetCell() == '0' && (cellToCheck.loc.col == 0 || cellToCheck.loc.row == 0 || cellToCheck.loc.col == width - 1 || cellToCheck.loc.row == height - 1)) || (cellToCheck.GetCell() == 'E' && width == 1 && height == 1))
        {
            return true;
        }
        for(i = 0, j = 1; j < 8; i += 2, j += 2)
        {
            Cell cellToAdd;
            if((cellToCheck.loc.col + checks[j] >= 0 && cellToCheck.loc.row + checks[i] >= 0 && cellToCheck.loc.col + checks[j] <= width && cellToCheck.loc.row + checks[i] <= height) && maze[cellToCheck.loc.row + checks[i]][cellToCheck.loc.col + checks[j]].GetVisitNum() == 0)
            {   
                maze[cellToCheck.loc.row + checks[i]][cellToCheck.loc.col + checks[j]].SetVisitNum(cellToCheck.GetVisitNum() + 1);
                cellToAdd = maze[cellToCheck.loc.row + checks[i]][cellToCheck.loc.col + checks[j]];
                queue.push(cellToAdd);
            }
        }
    }
    return false;
}

void Board::IsConnected()
{
    Cell curCell, cellToCheck;
    curCell = stack.top();
    path.push(stack.top());
    stack.pop();
    vector<int> checks = {-1,0,0,1,1,0,0,-1};
    int i, j;
    while(stack.size() != 0)
    {
        cellToCheck = stack.top();
        for(i = 0, j = 1; j < 8; i += 2, j += 2)
        {
            if(curCell.loc.col + checks[j] == cellToCheck.loc.col && curCell.loc.row + checks[i] == cellToCheck.loc.row && cellToCheck.GetVisitNum() == curCell.GetVisitNum() - 1)
            {
                cellToCheck.SetPath();
                path.push(cellToCheck);
                curCell = cellToCheck;
            }
        }
        stack.pop();
    }
    pathLen = path.size();
}